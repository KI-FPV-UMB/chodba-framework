
-standardne mqtt topicy:
	master -spravy pre master uzol (aplikaciu)
		msg=lifecycle => udrziava zoznam beziacich aplikacii
		msg=log => zaloguje danu spravu do konzoly
		msg=info => do konzoly zaloguje ziskane informacie o aplikacii
		msg=applications => zoznam podla filter=[running|all], type=[frontend|backend], posle na response_topic=<nazov_topicu>
			odpoved bude mat tiez nastavene msg=applications
		msg=workspaces => podla zoznamu "node_manager"-ov, posle na response_topic=<nazov_topicu>
		msg=approbations => zatial napevno, posle na response_topic=<nazov_topicu>
	node/<hostname>	-spravy pre dany uzol (spracovava node_manager)
		TODO spustanie/vypinanie aplikacii
	app/<nazov>	-ovladanie kazdej aplikacie (pozor, podla typu, nie instancie! t.j. sprava pride pre vsetky spustene instancie)
		msg=quit => mastrovi posle "lifecycle" spravu, ze konci
		msg=info => mastrovi posle "info" spravu o type aplikacie a topicoch, na ktore posiela/pocuva
		msg=status => mastrovi posle "lifecycle" spravu, ze je ok
		ostatne => mastrovi posle "log" spravu ze dostal neznamu spravu
	app/<nazov>/<node>	-ovladanie konkretnej instancie, moze spracovavat ten isty kod ako app/<nazov>

-poziadavky na app:
1) posiela informacie o zivotnom cykle na topic "master":
	"msg": "lifecycle"
	"name": nazov aplikacie (malymi pismenami, bez medzier, diakritiky)
	"type": "app" alebo "game"
	"id": unikatny identifikator (pocas jedneho behu aplikacie sa nesmie zmenit!)
	"node": hostname pocitaca, kde je spustena
	"status" - stav, co sa s aplikaciou deje:
		pri spustani: "starting"
		po spusteni: "ok"
		pri vypinani: "quitting"
	priklad: {"node": "mvagac-X230", "name": "priklad", "type": "app", "msg": "lifecycle", "id": "70e0c7db6a2834b141b26b80a39b9b", "status": "starting"}
2) pocuva topic "app/<svoj_nazov>"; prichodzia sprava ma vzdy "msg":
	"quit": prikaz na ukoncenie aplikacie
	"info": na topic "master" posle informacie o sebe:
		"msg": "info"
		"name": nazov aplikacie (malymi pismenami, bez medzier, diakritiky)
		"type": "app" alebo "game"
		"id": unikatny identifikator (pocas jedneho behu aplikacie sa nesmie zmenit!)
		"pub": info o topicoch, na ktore posiela spravy (publish)
		"sub": info o topicoch, na ktorych pocuva (subscribe)
		priklad: {"msg": "info", "pub": "", "sub": "abc", "type": "app", "name": "priklad", "id": "e4d3b84da554c5529d4c469cde86406"}
	"status": na topic "master" posle, ze je ok (atributy ako pri zivotnom cykle):
		priklad: {"msg": "lifecycle", "name": "priklad", "type": "app", "id": "399548a2b577edcad81a7e0a092f092", "status": "ok", "node": "mvagac-X230"}



TODO:
	pripravit priklad TkInter frontendu. bude podporovat 2 mody: 1 obrazovkova / viac obrazovkova. pricom sama oznami, kolko obrazoviek v tom
		multi mode vyzaduje (0=nepodporuje) podla toho by na tych 8 monitoroch mohlo ist naraz niekolko viac-obrazovkovych aplikacii
		(napr. 3 a 5, alebo 3 a 3 a 2, a pod.)
	frontend aplikacia by mala este vediet poslat layout klavesnice:
		dynamicke ovladanie/staticke (pri dynamickom sa pri kazdom odoslani vyziada novy layout)
		list komponentov, pri kazdom komponente: id, x, y, w, h, title, typ (button/button_submit/input_text/input_number/kreslenie)
	do dokumentu zhrnut podmienky na appku (na ake spravy ma ako reagovat)
	upravit hra2d-java, aby splnalo podmienky na appku. klavesnica-java sa zrusi, ked bude mobil
	na gitlab spravit dokument, kde opisem ako to cele rozchodit (aby si to mohol napr. aj Martin odskusat)


TEMY
rozvrh, obdy, mhd - data citaju z db. tam sa to bude plnit skriptami (tiez moznost robit na mac), alebo rucne
1) top priority
-?databaza [backend] - na zaklade danej spravy zapise udaj do db (asi key/value pary, ale pri kazdom aj zdroj - ze kto to poslal)
-qr kod pre mobilnu appku [frontend]
-daky python frontend ukazku (tkinter)
2) meet-and-code
-oznamy [frontend] - info aj spolocne (ked sa to spusti len automaticky), ale aj podla aprobacie (ked to niekto spusti mobilom)
-teplomer [backend] - posle nameranu teplotu kazdych n minut
-teplomer-range [backend] - prijima spravy s nameranou teplotou; ak klesne/stupne cez daku hodnotu, tak spusti teplomer-alert
-teplomer-alert [frontend] - zobrazi (vtipnu?) spravu, ze teplota je prilis vysoka/nizka
-rozvrh-prestavky [backend] - sleduje cas, a vzdy cez prestavku vysle signal na spustenie rozvrh-teraz
-rozvrh-teraz [frontend] - zobrazi co sa prave kde uci, + co bude najblizsie kde nasledovat (asi podla ucebni)
-rozvrh-cely [frontend] - zobrazi cely rozvrh. user by mal v mobile mat nastavenu aj aprobaciu, tak mu zobrazi len tu
-obedy-dnes [frontend] - zobrazi len, ze co je dnes na obed
-obedy-tyzden [frontend] - zobrazi obedy na cely tyzden
-mhd-teraz [frontend] - zobrazi, co ide najblizsich N minut (od skoly, ale aj od tajaku)
-mhd-cely [frontend] - celkovy prehlad co/kedy ide
-hra-... [frontend] - ovladanie musi reagovat na mqtt spravy; jackbox: https://www.youtube.com/watch?v=UZfNc_kbxKQ
-firmy [frontend] - reklama, oznamy ze niekoho hladaju, ...
-pocuvanie hovorenych povelov (pomocou google sluzby)
3) bc/mgr prace
-osoba-poloha [backend] - posle spravu, ze na definovanej pozicii (napr. pred kazdym monitorom) stoji nejaka osoba
-osoba-gesto [backend] - posle spravu, ze nejaka osoba spravila na kinect nejake gesto
-osoby-pozicie [backend] - ked pride sprava (poziadavka) tak zisti kde ktora osoba stoji a posle to inou spravou
-osoby-zapcha [backend] - dotazuje sa na pocty ludi a zaznamenava to do db. po dlhsom case bude vediet, kedy tam byva plno. potom bude dopredu
 vysielat spravu, ze sa blizi zapcha
-osoby-zapcha-alert [frontend] - zobrazi varovanie, ze bude plno...


FRAMEWORK
-rpi4:
	-nainstalovat a spustit mqtt (mosquitto)
	-pripojit ethernetom na internet, wifi nastavit ako AP (ale neroutovat!)
	-nainstalovat OpenCV, nastavit kameru
	-pripojit a nastavit senzor teploty a vlhkosti, mikrofon
	-pri starte:
		-na hlavnom uzle spustit app master
		-na vsetkych spustit node_manager
		-na hlavnom uzle cronom opakovane posielat mastrovi spravu run_backends
-mobilna appka, ktora zobrazi daky predefinovany screen
	-posielanie sprav ovladania (dola/doprava/...)
	-posielanie sprav na spustenie frontend appky (zoznam dostane zo servera!)
	-instalovana pomocou qr kodu
	-vzdy musi poslat aj dake svoje id (povedzme ze v appke si kazdy vyplni nick); aby bolo mozne rozlisit viac hracov
	-tiez by si mal mat moznost nastavit aprobaciu (napr. pre rozvrh, ale aj pre oznamy a pod.)
	-musi informovat (rovno umoznit?), ze ked chce user s tym pracovat, musi sa prihlasit na lokalnu rpi wifi
-moznost instalovania dalsich apiek studentami (brat to rovno s gitu?)

=> backend appky
	-specialna backend appka na spustanie a vypinanie appiek (bude bezat na kazdom rpi)
	-backend appka, ktora bude planovat (nahodne) frontend appky. a reagovat na ukoncovanie frontend appiek
	-db backend appka
=> demo frontend appka
	-2 mody: 1 obrazovka / viac obrazoviek (dakym sposobom oznami, kolko obrazok v multi mode podporuje)
=> dobre opisat cely system kanalov
	mosquitto_sub -d -t master
	mosquitto_pub -t app/frontend_runner -m "info"
	mosquitto_pub -t app/frontend_runner -m "status"
	mosquitto_pub -t app/frontend_runner -m "quit"
	mosquitto_pub -t run_frontend/1 -m "asd"

KONFIGURACIA (HW)
-mozaika zo starych monitorov (asi vsetko v riadku)
-projektor+rpi4 (kamera, kinect, mikrofon, teplomer, vlhkomer)


TODO
-moznost pustenia rezimu streamovania videa. to by mala mat appka pod kontrolou; resp. spravit appku, ktora pusti stream a bude zobrazovat jeho patricne casti na prislusnej obrazovke. pricom nemusi byt zrovna na vsetkych 8.  omxplayer --crop '0 0 320 347' http://192.168.0.20:8080
-farebne ovladatelne svetla
-automaticke otvaranie okna von
-detekcia otvorenych dveri na ucebnu
-polievanie kvetu, fontanka???
-home automation (milan!)
-mysliet na nase temy (pv, robotika, vysokovykonne pocitanie, iot, ...)
-docker??


