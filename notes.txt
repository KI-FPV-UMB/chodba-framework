
-standardne mqtt topicy:
	master -spravy pre master uzol (aplikaciu)
		msg=lifecycle => udrziava zoznam beziacich aplikacii
		msg=log => zaloguje danu spravu do konzoly
		msg=info => do konzoly zaloguje ziskane informacie o aplikacii
		msg=applications => zoznam podla filter=[running|all], type=[frontend|backend], posle na response_topic=<nazov_topicu>
			odpoved bude mat tiez nastavene msg=applications
		msg=workspaces => podla zoznamu "node_manager"-ov, posle na response_topic=<nazov_topicu>
		msg=approbations => zatial napevno, posle na response_topic=<nazov_topicu>
	node/<hostname>	-spravy pre dany uzol
		TODO spustanie/vypinanie aplikacii
	apps/<nazov>	-ovladanie kazdej aplikacie
		msg=quit => mastrovi posle "lifecycle" spravu, ze konci
		msg=info => mastrovi posle "info" spravu o type aplikacie a topicoch, na ktore posiela/pocuva
		msg=status => mastrovi posle "lifecycle" spravu, ze je ok
		ostatne => mastrovi posle "log" spravu ze dostal neznamu spravu

	approbations-request, approbations-response	-zoznam vsetkych aprobacii
	applications-request, applications-response	-zoznam aplikacii
	workspaces-request, workspaces-response		-zoznam workspaces

appka si povie:
	typy aplikacii: game, app, system
	typ ovladania:
		dynamicke ovladanie/staticke (pri dynamickom sa pri kazdom odoslani vyziada novy layout)
		list komponentov, pri kazdom komponente: id, x, y, w, h, title, typ (button/button_submit/input_text/input_number/kreslenie)

TODO:
	pripravit priklad TkInter frontendu
	frontend aplikacia by mala este vediet poslat layout klavesnice (+oznamit, ci je dynamicky/staticky)
	do dokumentu zhrnut podmienky na appku (na ake spravy ma ako reagovat)
	upravit hra2d-java, aby splnalo podmienky na appku. klavesnica-java sa zrusi, ked bude mobil
	pridat aj hra2d-python; spravit pomocou base kniznice
	na gitlab spravit dokument, kde opisem ako to cele rozchodit (aby si to mohol napr. aj Martin odskusat)


TEMY
rozvrh, obdy, mhd - data citaju z db. tam sa to bude plnit skriptami (tiez moznost robit na mac), alebo rucne
1) top priority
-databaza [backend] - na zaklade danej spravy zapise udaj do db (asi key/value pary, ale pri kazdom aj zdroj - ze kto to poslal)
-qr kod pre mobilnu appku [frontend]
-daky python frontend ukazku (tkinter)
2) meet-and-code
-oznamy [frontend] - info aj spolocne (ked sa to spusti len automaticky), ale aj podla aprobacie (ked to niekto spusti mobilom)
-teplomer [backend] - posle nameranu teplotu kazdych n minut
-teplomer-range [backend] - prijima spravy s nameranou teplotou; ak klesne/stupne cez daku hodnotu, tak spusti teplomer-alert
-teplomer-alert [frontend] - zobrazi (vtipnu?) spravu, ze teplota je prilis vysoka/nizka
-rozvrh-prestavky [backend] - sleduje cas, a vzdy cez prestavku vysle signal na spustenie rozvrh-teraz
-rozvrh-teraz [frontend] - zobrazi co sa prave kde uci, + co bude najblizsie kde nasledovat (asi podla ucebni)
-rozvrh-cely [frontend] - zobrazi cely rozvrh. user by mal v mobile mat nastavenu aj aprobaciu, tak mu zobrazi len tu
-obedy-dnes [frontend] - zobrazi len, ze co je dnes na obed
-obedy-tyzden [frontend] - zobrazi obedy na cely tyzden
-mhd-teraz [frontend] - zobrazi, co ide najblizsich N minut (od skoly, ale aj od tajaku)
-mhd-cely [frontend] - celkovy prehlad co/kedy ide
-hra-... [frontend] - ovladanie musi reagovat na mqtt spravy; jackbox: https://www.youtube.com/watch?v=UZfNc_kbxKQ
-firmy [frontend] - reklama, oznamy ze niekoho hladaju, ...
-pocuvanie hovorenych povelov (pomocou google sluzby)
3) bc/mgr prace
-osoba-poloha [backend] - posle spravu, ze na definovanej pozicii (napr. pred kazdym monitorom) stoji nejaka osoba
-osoba-gesto [backend] - posle spravu, ze nejaka osoba spravila na kinect nejake gesto
-osoby-pozicie [backend] - ked pride sprava (poziadavka) tak zisti kde ktora osoba stoji a posle to inou spravou
-osoby-zapcha [backend] - dotazuje sa na pocty ludi a zaznamenava to do db. po dlhsom case bude vediet, kedy tam byva plno. potom bude dopredu
 vysielat spravu, ze sa blizi zapcha
-osoby-zapcha-alert [frontend] - zobrazi varovanie, ze bude plno...


FRAMEWORK
-rpi4:
	-nainstalovat a spustit mqtt (mosquitto)
	-pripojit ethernetom na internet, wifi nastavit ako AP (ale neroutovat!)
	-nainstalovat OpenCV
	-nastavit kameru
	-pripojit a nastavit senzor teploty a vlhkosti
	-pripojit a nastavit mikrofon
	-na hlavnom spustit master
	-na vsetkych spustit node_manager
	-po urcitom case posli spravu na spustenie backend appiek. resp. to by sa mohlo spustat v pravidelnych intervaloch (ak sa napr. niektory
	 uzol pusti neskor, alebo sa jednoducho restartne, tak takto sa odpovedajuce backendappky len spustia nanovo)
-spustenie frameworku sposobi spustenie backend appiek
	-pri spustani frontend appky sa zisti, ci je daky live user. ak nie, tak by ju spustilo na viac monitorov; ak je tak len na jeden
	 resp. ak je vedla seba volnych (neobsadenych live userom) tolko monitorov, kolko vyzaduje, tak ich spusti; inac len na 1
	-dalsia specialna backend appka bude nahodne spustat frontend appky (aby tam stale nieco bezalo). a bude reagovat na spravy ukoncenia
	 frontend appky (hned spusti nahodne daco dalsie) => frontend_planner
-spustena frontend appka
	-moze podporovat 2 mody: 1 obrazovkova / viac obrazovkova. pricom sama oznami, kolko obrazoviek v tom multi mode vyzaduje (0=nepodporuje)
	 podla toho by na tych 8 monitoroch mohlo ist naraz niekolko viac-obrazovkovych aplikacii (napr. 3 a 5, alebo 3 a 3 a 2, a pod.)
-mobilna appka, ktora zobrazi daky predefinovany screen
	-posielanie sprav ovladania (dola/doprava/...)
	-posielanie sprav na spustenie frontend appky (zoznam dostane zo servera!)
	-instalovana pomocou qr kodu
	-vzdy musi poslat aj dake svoje id (povedzme ze v appke si kazdy vyplni nick); aby bolo mozne rozlisit viac hracov
	-tiez by si mal mat moznost nastavit aprobaciu (napr. pre rozvrh, ale aj pre oznamy a pod.)
	-musi informovat (rovno umoznit?), ze ked chce user s tym pracovat, musi sa prihlasit na lokalnu rpi wifi
-moznost instalovania dalsich apiek studentami (brat to rovno s gitu?)

=> kazda aplikacia:
	*odpoved na mqtt spravu, ze na ake temy zverejnuje a na ake pocuva
	*reaguje na spravu - ziadost o ukoncenie
	*pri konceni posle spravu, ze konci
	*kazda aplikacia by teda mala otvorit kanal s nazvom rovnakym, ako je sama (alebo daco podobne)
=> spustenie backend aplikacii
	-kazda si urci, na ktorom rpi ma bezat (3 moznosti: na konkretnom[n]/na vsetkych[*]/na lubovolnom[?])
=> backend appky
	-specialna backend appka na spustanie a vypinanie appiek (bude bezat na kazdom rpi)
	-backend appka, ktora bude planovat (nahodne) frontend appky. a reagovat na ukoncovanie frontend appiek
	-db backend appka
=> demo frontend appka
	-2 mody: 1 obrazovka / viac obrazoviek (dakym sposobom oznami, kolko obrazok v multi mode podporuje)
=> dobre opisat cely system kanalov
	mosquitto_sub -d -t master
	mosquitto_pub -t apps/frontend_runner -m "info"
	mosquitto_pub -t apps/frontend_runner -m "status"
	mosquitto_pub -t apps/frontend_runner -m "quit"
	mosquitto_pub -t run_frontend/1 -m "asd"

KONFIGURACIA (HW)
-mozaika zo starych monitorov (asi vsetko v riadku)
-projektor+rpi4 (kamera, kinect, mikrofon, teplomer, vlhkomer)


TODO
-moznost pustenia rezimu streamovania videa. to by mala mat appka pod kontrolou; resp. spravit appku, ktora pusti stream a bude zobrazovat jeho patricne casti na prislusnej obrazovke. pricom nemusi byt zrovna na vsetkych 8.  omxplayer --crop '0 0 320 347' http://192.168.0.20:8080
-farebne ovladatelne svetla
-automaticke otvaranie okna von
-detekcia otvorenych dveri na ucebnu
-polievanie kvetu, fontanka???
-home automation (milan!)
-mysliet na nase temy (pv, robotika, vysokovykonne pocitanie, iot, ...)
-docker??


